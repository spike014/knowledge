# MySQL

## 目录

- [MySQL](#mysql)
  - [目录](#目录)
  - [字符集](#字符集)
  - [MySQL 基础结构](#mysql-基础结构)
  - [MySQL 存储引擎架构了解吗？](#mysql-存储引擎架构了解吗)
  - [MyISAM 和 InnoDB 的区别是什么？](#myisam-和-innodb-的区别是什么)
  - [MySQL 锁](#mysql-锁)
    - [表级锁和行级锁了解吗？有什么区别？](#表级锁和行级锁了解吗有什么区别)
    - [行级锁的使用有什么注意事项？](#行级锁的使用有什么注意事项)
    - [共享锁和排他锁呢？](#共享锁和排他锁呢)
    - [InnoDB 有哪几类行锁？](#innodb-有哪几类行锁)
  - [如何排查查询是否使用了索引？使用了那些索引？](#如何排查查询是否使用了索引使用了那些索引)
  - [主从同步](#主从同步)
    - [在Mysql的主从架构中有很多问题：](#在mysql的主从架构中有很多问题)

## 字符集

`MySQL` 字符编码集中有两套 `UTF-8` 编码实现：`utf8` 和 `utf8mb4`。

如果使用 `utf8` 的话，存储 `emoji` 符号和一些比较复杂的汉字、繁体字就会出错。

常见的字符集有 ASCII、GB2312、GBK、UTF-8......。

不同的字符集的主要**区别**在于：

- 可以表示的字符范围
- 编码方式

`MySQL` 字符编码集中有两套 `UTF-8` 编码实现：

- `utf8` ： utf8编码只支持1-3个字节 。 在 utf8 编码中，中文是占 3 个字节，其他数字、英文、符号占一个字节。但 emoji 符号占 4 个字节，一些较复杂的文字、繁体字也是 4 个字节。
- `utf8mb4` ： UTF-8 的完整实现，正版！最多支持使用 4 个字节表示字符，因此，可以用来存储 emoji 符号。

为什么有两套 UTF-8 编码实现呢？ 原因如下：

![](./image/image-20211008164542347.png)

因此，如果你需要存储emoji类型的数据或者一些比较复杂的文字、繁体字到 MySQL 数据库的话，数据库的编码一定要指定为utf8mb4 而不是utf8 ，要不然存储的时候就会报错了。

## MySQL 基础结构

执行一条 `SQL`，在 `MySQL` 的过程？

![](./13526879-3037b144ed09eb88.png)

- 连接器： 身份认证和权限相关(登录 MySQL 的时候)。
- 查询缓存： 执行查询语句的时候，会先查询缓存（MySQL 8.0 版本后移除，因为这个功能不太实用）。
- 分析器： 没有命中缓存的话，SQL 语句就会经过分析器，分析器说白了就是要先看你的 SQL 语句要干嘛，再检查你的 SQL 语句语法是否正确。
- 优化器： 按照 MySQL 认为最优的方案去执行。
- 执行器： 执行语句，然后从存储引擎返回数据。 执行语句之前会先判断是否有权限，如果没有权限的话，就会报错。
- 插件式存储引擎 ： 主要负责数据的存储和读取，采用的是插件式架构，支持 InnoDB、MyISAM、Memory 等多种存储引擎。

## MySQL 存储引擎架构了解吗？

MySQL 存储引擎采用的是插件式架构，支持多种存储引擎，我们甚至可以为不同的数据库表设置不同的存储引擎以适应不同场景的需要。存储引擎是基于表的，而不是数据库。

并且，你还可以根据 MySQL 定义的存储引擎实现标准接口来编写一个属于自己的存储引擎。这些非官方提供的存储引擎可以称为第三方存储引擎，区别于官方存储引擎。像目前最常用的 InnoDB 其实刚开始就是一个第三方存储引擎，后面由于过于优秀，其被 Oracle 直接收购了。

## MyISAM 和 InnoDB 的区别是什么？

`MyISAM` 不支持事务和行级锁，而且最大的缺陷就是崩溃后无法安全恢复。

1. 是否支持行级锁

    MyISAM 只有表级锁(table-level locking)，而 InnoDB 支持行级锁(row-level locking)和表级锁,默认为行级锁。

2. 是否支持事务

    MyISAM 不提供事务支持。

    InnoDB 提供事务支持，实现了 SQL 标准定义了四个隔离级别，具有提交(commit)和回滚(rollback)事务的能力。并且，InnoDB 默认使用的 REPEATABLE-READ（可重读）隔离级别是可以解决幻读问题发生的（基于 MVCC 和 Next-Key Lock）。

3. 是否支持外键

    MyISAM 不支持，而 InnoDB 支持。

    外键对于维护数据一致性非常有帮助，但是对性能有一定的损耗。因此，通常情况下，我们是不建议在实际生产项目中使用外键的，在业务代码中进行约束即可！

4. 是否支持数据库异常崩溃后的安全恢复

    MyISAM 不支持，而 InnoDB 支持。

    使用 InnoDB 的数据库在异常崩溃后，数据库重新启动的时候会保证数据库恢复到崩溃前的状态。这个恢复的过程依赖于 redo log 。

5. 是否支持 MVCC

    MyISAM 不支持，而 InnoDB 支持。

    毕竟 MyISAM 连行级锁都不支持。MVCC 可以看作是行级锁的一个升级，可以有效减少加锁操作，提高性能。

6. 索引实现不一样。

    虽然 MyISAM 引擎和 InnoDB 引擎都是使用 B+Tree 作为索引结构，但是两者的实现方式不太一样。

    InnoDB 引擎中，其数据文件本身就是索引文件。相比 MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按 B+Tree 组织的一个索引结构，树的叶节点 data 域保存了完整的数据记录。

## MySQL 锁

### 表级锁和行级锁了解吗？有什么区别？

MyISAM 仅仅支持表级锁(table-level locking)，一锁就锁整张表，这在并发写的情况下性非常差。

InnoDB 不光支持表级锁(table-level locking)，还支持行级锁(row-level locking)，默认为行级锁。行级锁的粒度更小，仅对相关的记录上锁即可（对一行或者多行记录加锁），所以对于并发写入操作来说， InnoDB 的性能更高。

表级锁和行级锁对比 ：

- 表级锁： MySQL 中锁定粒度最大的一种锁，是针对非索引字段加的锁，对当前操作的整张表加锁，实现简单，**资源消耗也比较少，加锁快，不会出现死锁。其锁定粒度最大，触发锁冲突的概率最高，并发度最低**，MyISAM 和 InnoDB 引擎都支持表级锁。

- 行级锁： MySQL 中锁定粒度最小的一种锁，是针对索引字段加的锁，只针对当前操作的行记录进行加锁。 行级锁能大大减少数据库操作的冲突。**其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。**

### 行级锁的使用有什么注意事项？

**InnoDB 的行锁是针对索引字段加的锁**，表级锁是针对非索引字段加的锁。**当我们执行 UPDATE、DELETE 语句时，如果 WHERE 条件中字段没有命中唯一索引或者索引失效的话，就会导致扫描全表对表中的所有行记录进行加锁。**

不过，很多时候即使用了索引也有可能会走全表扫描，这是因为 MySQL 优化器的原因。

### 共享锁和排他锁呢？

不论是表级锁还是行级锁，都存在共享锁（Share Lock，S 锁）和排他锁（Exclusive Lock，X 锁）这两类：

**共享锁（S 锁）** ：又称**读锁**，事务在读取记录的时候获取共享锁，允许多个事务同时获取（锁兼容）。

**排他锁（X 锁）** ：又称**写锁/独占锁**，事务在修改记录的时候获取排他锁，不允许多个事务同时获取。如果一个记录已经被加了排他锁，那其他事务不能再对这条事务加任何类型的锁（锁不兼容）。

**排他锁与任何的锁都不兼容，共享锁仅和共享锁兼容。**

### InnoDB 有哪几类行锁？
MySQL InnoDB 支持三种行锁定方式：

- 记录锁（Record Lock） ：也被称为记录锁，属于单个行记录上的锁。
- 间隙锁（Gap Lock） ：锁定一个范围，不包括记录本身。
- 临键锁（Next-key Lock） ：Record Lock+Gap Lock，锁定一个范围，包含记录本身。记录锁只能锁住已经存在的记录，为了避免插入新记录，需要依赖间隙锁。
InnoDB 的默认隔离级别 RR（可重读）是可以解决幻读问题发生的，主要有下面两种情况：

  - 快照读（一致性非锁定读） ：由 MVCC 机制来保证不出现幻读。
  - 当前读 （一致性锁定读）： 使用 Next-Key Lock 进行加锁来保证不出现幻读。

## 如何排查查询是否使用了索引？使用了那些索引？


## 主从同步

### 在Mysql的主从架构中有很多问题：

- 主库的写入压力比较大的时候，主从复制的延迟会变得比较高，由于我们其复制的是binlog，他会走完所有的事务。

- 增加从节点速度慢，由于我们需要将数据全量的复制到从节点，如果主节点此时存量的数据已经很多，那么扩展一个从节点速度就会很慢高。

- 对于数据量比较大的数据库，备份的速度很慢。

- 成本变高，如果我们的数据库的容量比较大，那么我们相应的所有从节点的容量都需要和主数据库一样大,我们的成本将会随着我们所需要从数据库的数量进行线性增加。

